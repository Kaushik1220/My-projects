# -*- coding: utf-8 -*-
"""webapp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HxoHDf_REDBZYHENldzkCNURUU-zV6M4
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

!pip install -q pyngrok

!pip install -q streamlit

!pip install -q streamlit_ace

import streamlit as st
from pyngrok import ngrok

dataset=pd.read_csv("/content/Fraud.csv")

dataset.head()

dataset.tail()

dataset.describe()

dataset.select_dtypes(include="object")

dataset.select_dtypes(include=["int64","float64"]).columns

len(dataset.select_dtypes(include=["int64","float64"]).columns)

len(dataset.select_dtypes(include="object").columns)

dataset.isnull().values.any()

"""#dealing with null values"""

dataset.isnull().sum()

dataset.select_dtypes(include=["int64","float64"]).columns

plt.figure(figsize=(16,9))
sns.heatmap(dataset.isnull())
plt.show()

#num columns with null values
#amount,'oldbalanceOrg','newbalanceOrig','newbalanceDest',"isFraud"
dataset['amount']=dataset['amount'].fillna(dataset['amount'].mean())
dataset['oldbalanceOrg']=dataset['oldbalanceOrg'].fillna(dataset['oldbalanceOrg'].median())
dataset['newbalanceOrig']=dataset['newbalanceOrig'].fillna(dataset['newbalanceOrig'].median())
dataset['oldbalanceDest']=dataset['oldbalanceDest'].fillna(dataset['oldbalanceDest'].median())
dataset['newbalanceDest']=dataset['newbalanceDest'].fillna(dataset[  'newbalanceDest'].median())

dataset.isnull().sum()

dataset['nameOrig']=dataset['nameOrig' ].fillna(dataset['nameOrig'].mode()[0])

dataset['nameDest']=dataset['nameDest' ].fillna(dataset['nameDest'].mode()[0])

dataset.isnull().sum()

dataset['isFraud']= dataset['isFraud' ].fillna(dataset['isFraud'].mode()[0])

dataset.drop(columns='isFlaggedFraud')

dataset.drop(columns='newbalanceOrig')

dataset.head()

dataset=dataset.drop(columns=['newbalanceOrig','isFlaggedFraud'])

dataset.head()

dataset.isnull().values.any()

"""# dealing with categorical data"""

dataset.select_dtypes(include="object").columns

dataset['type'].unique()

dataset['nameOrig'].unique()

dataset=dataset.drop(columns=['nameOrig','nameDest'])

dataset.head()

dataset=pd.get_dummies(data=dataset,drop_first=True)

dataset.head()

sns.countplot(dataset['isFraud'])

"""# Data analysis

# Splitting the dataset
"""

x=dataset.drop(columns='isFraud')

y=dataset['isFraud']

from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test = train_test_split(
    x, y, test_size=0.2, random_state=0)

x_train.shape

y_train.shape

y_test.shape

x_test.shape

"""# Feature Scaling"""

from sklearn.preprocessing import StandardScaler

sc=StandardScaler()

x_train=sc.fit_transform(x_train)

x_test=sc.transform(x_test)

"""# Training the  model"""

from sklearn.linear_model import LogisticRegression

classifier_lr=LogisticRegression(random_state=0)

y_train.shape

classifier_lr.fit(x_train,y_train)

y_pred=classifier_lr.predict(x_test)

from sklearn.metrics import accuracy_score,confusion_matrix,f1_score,precision_score,recall_score

acc=accuracy_score(y_test,y_pred)
f1=f1_score(y_test,y_pred)
pre=precision_score(y_test,y_pred)
rec=recall_score(y_test,y_pred)

results=pd.DataFrame([['logistic Regression',acc,f1,pre,rec]],
                      columns=['Model','Accuracy','F1 score','Precision score','Recall score'])

results

cm=confusion_matrix(y_test,y_pred)
print(cm)

from sklearn.model_selection import cross_val_score
accuracies=cross_val_score(estimator=classifier_lr,X=x_train,y=y_train,cv=10)
print("Accuracy is {:.2f} %".format(accuracies.mean()*100))
print("standard Deviation is {:.2f}".format(accuracies.std()*100))

dataset.head()

singleobs=[[1,8789,12345,3456,2345,0,1,1,0]]

pred=classifier_lr.predict(singleobs)

print(pred)

if(pred==[0.]):
  print("Not Fraud")
else:
  print("Fraud")

import pickle 
pickle_out = open("classifier.pkl", mode = "wb") 
pickle.dump(classifier_lr, pickle_out) 
pickle_out.close()

pickle_in = open('classifier.pkl', 'rb') 
classifier = pickle.load(pickle_in)

dataset.head()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import pickle
# import streamlit as st
#  
# # loading the trained model
# pickle_in = open('classifier.pkl', 'rb') 
# classifier = pickle.load(pickle_in)
# @st.cache()
#   
# def predictor(step,amount,oldbalanceOrg,oldbalanceDest,newbalanceDest,type_CASH_OUT,type_DEBIT,type_PAYMENT,type_TRANSFER):
#   if type_CASH_OUT==1:
#     type_DEBIT=0
#     type_PAYMENT=0
#     type_TRANSFER=0
#   if type_DEBIT==1:
#     type_CASH_OUT=0
#     type_PAYMENT=0
#     type_TRANSFER=0
#   if type_PAYMENT==1:
#     type_DEBIT=0
#     type_CASH_OUT=0
#     type_TRANSFER=0
#   if type_TRANSFER==1:
#     type_DEBIT=0
#     type_PAYMENT=0
#     type_CASH_OUT=0
#   predictor = classifier.predict( 
#         [[step,amount,oldbalanceOrg,oldbalanceDest,newbalanceDest,type_CASH_OUT,type_DEBIT,type_PAYMENT,type_TRANSFER]])
#   if predictor == 0:
#         pred ='Not Fraud'
#   else:
#         pred = 'Fraud'
#   return pred
# def main():       
#   # front end elements of the web page 
#   html_temp = """ 
#   <div style ="background-color:yellow;padding:13px"> 
#   <h1 style ="color:black;text-align:center;">Streamlit Fraud Prediction ML App</h1> 
#   </div> 
#   """
#       
#     # display the front end aspect
#   st.markdown(html_temp, unsafe_allow_html = True) 
#       
#     # following lines create boxes in which user can enter data required to make prediction 
#   step = st.number_input("Enter step")
#   amount= st.number_input("Enter amount") 
#   oldbalanceOrg = st.number_input("Enter the old balance") 
#   oldbalanceDest= st.number_input("Enter old balance destination")
#   newbalanceDest = st.number_input("Enter the new balance destination")
#   type_CASH_OUT=st.number_input("Enter if cashout(Yes-1,No-0")
#   type_DEBIT=st.number_input("Enter if debit(Yes-1,No-0")
#   type_PAYMENT=st.number_input("Enter if payment(Yes-1,No-0")
# 
#   type_TRANSFER=st.number_input("Enter if transfer(Yes-1,No-0")
#   st.success('The customer')
#       
#     # when 'Predict' is clicked, make the prediction and store it 
#   if st.button("Predict"): 
#       result = predictor(step,amount,oldbalanceOrg,oldbalanceDest,newbalanceDest,type_CASH_OUT,type_DEBIT,type_PAYMENT,type_TRANSFER)
#       st.success('The customer is {}'.format(result))
#       print(result)
#   
# if __name__=='__main__': 
#     main()
# 
#

!streamlit run app.py&npx localtunnel --port 8501